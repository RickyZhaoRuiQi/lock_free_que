gcc提供了两个函数
bool __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)
type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)
这两个函数提供原子的比较和交换，如果*ptr == oldval,就将newval写入*ptr,
第一个函数在相等并写入的情况下返回true.
第二个函数在返回操作之前的值。

X86中有一个CMPXCHG的汇编指令 保证操作的原子性

在多线程环境下 有以下情景
------------------------------------------------------------------------------------------
1:对同一链队列进行入队操作时 
2:一个线程正在将新的队列节点挂载到队尾节点的next上
3:这个线程还没来的及更新队尾节点,同一时刻另一个线程也在进行入队操作将新的队列节点也挂在到了没更新的队尾节点，那么先挂载的节点就丢失了
------------------------------------------------------------------------------------------
为了解决多线程环境下的这些问题
第一时间肯定想到了加上互斥锁 控制同一时刻只能有一个线程可以对队列进行写操作
但是加锁的操作太消耗系统资源了，很繁重
因为对临界区的操作只有一步 就是对队列的尾节点进行更新
只要让这一步进行的是原子操作就可以了
所以使用到了CAS操作
------------------------------------------------------------------------------------------
因此用cpp写了一个无锁队列类，测试
多线程cas入队数据完整，普通多线程入队会造成数据丢失每次结果不一致。
多线程cas出队也能完整出，普通多线程出队会出现double free的错误，提示重复释放同一片空间
------------------------------------------------------------------------------------------
启动4个线程,每个线程入队十万个数据的情况下。
使用cas程序用时：280000/1000000(s),250000/1000000(s),250000/1000000(s),250000/1000000(s),260000/1000000(s)
使用互斥锁程序用时：390000/1000000(s),270000/1000000(s)，280000/1000000(s),270000/1000000(s),270000/1000000(s)
